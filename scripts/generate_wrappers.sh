#!/usr/bin/env bash
# AIChat Function Wrapper Generator
# Version: 1.2.0 (Extract from tools.txt)
# Description: Automatically generates executable wrapper scripts for AIChat agent functions

set -e

# ============================================================================
# Constants and Configuration
# ============================================================================

readonly SCRIPT_VERSION="1.2.0"
readonly SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default configuration
DEFAULT_AGENT="sh-ai"
AGENT_NAME="${DEFAULT_AGENT}"
FORCE_OVERWRITE=false
CLEAN_MODE=false
DRY_RUN=false
VERBOSE=false
VALIDATE_MODE=false
FILTER_PATTERN=""

# Path configuration
FUNCTIONS_ROOT="$(cd "${SCRIPT_DIR}/../../.." && pwd)"
BIN_DIR="${FUNCTIONS_ROOT}/bin"

# Status icons
readonly ICON_SUCCESS="âœ…"
readonly ICON_ERROR="âŒ"
readonly ICON_WARNING="âš ï¸"
readonly ICON_INFO="â„¹ï¸"
readonly ICON_GENERATE="ðŸ”§"
readonly ICON_CLEAN="ðŸ§¹"
readonly ICON_CHECK="ðŸ”"

# ============================================================================
# Logging Functions
# ============================================================================

log_info() {
    echo "${ICON_INFO} $*"
}

log_success() {
    echo "${ICON_SUCCESS} $*"
}

log_warning() {
    echo "${ICON_WARNING} $*" >&2
}

log_error() {
    echo "${ICON_ERROR} $*" >&2
}

log_verbose() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "  â†’ $*" >&2
    fi
}

log_dry_run() {
    if [[ "$DRY_RUN" == "true" ]]; then
        echo "[DRY-RUN] $*"
    fi
}

# ============================================================================
# Error Handling Functions
# ============================================================================

handle_error() {
    local error_type="$1"
    local error_context="${2:-}"
    
    case "$error_type" in
        "missing_tools_txt")
            log_error "tools.txt not found"
            log_error "Expected location: $error_context"
            log_error "Please generate tools.txt first using: argc --argc-export txt tools.sh > tools.txt"
            return 1
            ;;
        "missing_tools")
            log_error "tools.sh not found"
            log_error "Expected location: $error_context"
            log_error "Please ensure tools.sh exists in the agent directory"
            return 1
            ;;
        "permission_denied")
            log_error "Permission denied"
            log_error "Location: $error_context"
            log_error "Try: chmod +x $error_context"
            return 1
            ;;
        "bin_dir_creation_failed")
            log_error "Failed to create bin directory"
            log_error "Location: $error_context"
            log_error "Check permissions and disk space"
            return 1
            ;;
        "wrapper_generation_failed")
            log_error "Failed to generate wrapper"
            log_error "Function: $error_context"
            return 1
            ;;
        "no_functions_found")
            log_warning "No functions found in tools.txt"
            log_warning "Location: $error_context"
            log_warning "Please check your tools.txt file"
            return 1
            ;;
        *)
            log_error "Unknown error: $error_type"
            log_error "Context: $error_context"
            return 1
            ;;
    esac
}

# ============================================================================
# Usage and Version Functions
# ============================================================================

show_usage() {
    cat << EOF
AIChat Function Wrapper Generator v${SCRIPT_VERSION}

Usage:
  ${SCRIPT_NAME} [options]

Description:
  Automatically generates executable wrapper scripts for AIChat agent functions.
  This solves the AIChat function invocation issue where AIChat looks for
  executable files matching function names rather than calling functions in tools.sh.
  
  The script extracts function names from tools.txt (generated by argc).

Options:
  --agent <name>      Agent name (default: ${DEFAULT_AGENT})
  --filter <pattern>  Filter functions by regex pattern (e.g., 'ssh_exec.*')
  --force            Force overwrite existing wrappers
  --clean            Clean obsolete wrappers that no longer exist in tools.txt
  --validate         Validate existing wrappers without generating new ones
  --dry-run          Show what would be done without executing
  --verbose          Show detailed information during execution
  --help             Show this help message
  --version          Show version information

Examples:
  # Generate wrappers for sh-ai agent
  ${SCRIPT_NAME} --agent sh-ai --verbose

  # Force regenerate all wrappers
  ${SCRIPT_NAME} --agent sh-ai --force

  # Validate existing wrappers
  ${SCRIPT_NAME} --agent sh-ai --validate --verbose

  # Generate only ssh_exec related wrappers
  ${SCRIPT_NAME} --agent sh-ai --filter 'ssh_exec.*'

Note:
  Before running this script, generate tools.txt using:
    cd ~/.config/aichat/functions/agents/sh-ai
    argc --argc-export txt tools.sh > tools.txt

Exit Codes:
  0  Success
  1  General error
  2  Invalid arguments
  3  Configuration error
  4  Generation error

EOF
}

show_version() {
    cat << EOF
AIChat Function Wrapper Generator
Version: ${SCRIPT_VERSION}
Copyright (c) 2024

This tool is part of the SH-AI project and is designed to work with
the AIChat agent framework and llm-functions.

Changes in v1.2.0:
  - Extract functions from tools.txt instead of index.yaml
  - Simpler, more reliable function detection
  - Support for argc-generated function lists

EOF
}

# ============================================================================
# Command Line Argument Parsing
# ============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --agent)
                if [[ -z "${2:-}" ]]; then
                    log_error "Missing argument for --agent"
                    show_usage
                    exit 2
                fi
                AGENT_NAME="$2"
                shift 2
                ;;
            --filter)
                if [[ -z "${2:-}" ]]; then
                    log_error "Missing argument for --filter"
                    show_usage
                    exit 2
                fi
                FILTER_PATTERN="$2"
                shift 2
                ;;
            --force)
                FORCE_OVERWRITE=true
                shift
                ;;
            --clean)
                CLEAN_MODE=true
                shift
                ;;
            --validate)
                VALIDATE_MODE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --help|-h)
                show_usage
                exit 0
                ;;
            --version|-v)
                show_version
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 2
                ;;
        esac
    done
}

# ============================================================================
# Function Extraction Functions (From tools.txt)
# ============================================================================

# Extract function names from tools.txt
extract_functions_from_tools_txt() {
    local tools_txt="$1"
    
    if [[ ! -f "$tools_txt" ]]; then
        handle_error "missing_tools_txt" "$tools_txt"
        return 1
    fi
    
    log_verbose "Extracting functions from tools.txt"
    
    # Extract function names from tools.txt
    # Skip comment lines (starting with #)
    # Skip empty lines
    # Each function name should be on its own line
    local functions
    functions=$(grep -v '^#' "$tools_txt" | \
                grep -v '^[[:space:]]*$' | \
                grep -E '^[a-zA-Z_][a-zA-Z0-9_]*$' | \
                sort -u)
    
    if [[ -z "$functions" ]]; then
        log_verbose "No functions found in tools.txt"
        return 1
    fi
    
    echo "$functions"
    return 0
}

# Validate a function name
validate_function_name() {
    local func_name="$1"
    
    # Function name must:
    # - Start with a letter or underscore
    # - Contain only letters, numbers, and underscores
    # - Not be empty
    if [[ -z "$func_name" ]]; then
        return 1
    fi
    
    if [[ ! "$func_name" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
        log_verbose "Invalid function name: $func_name"
        return 1
    fi
    
    return 0
}

# Extract and validate function list from tools.txt
extract_function_list() {
    local tools_txt="$1"
    
    log_verbose "Extracting function list from: $tools_txt"
    
    local functions
    if ! functions=$(extract_functions_from_tools_txt "$tools_txt"); then
        handle_error "no_functions_found" "$tools_txt"
        return 1
    fi
    
    # Validate and deduplicate function names
    local validated_functions=()
    local seen_functions=()
    
    while IFS= read -r func; do
        # Skip empty lines
        [[ -z "$func" ]] && continue
        
        # Validate function name
        if ! validate_function_name "$func"; then
            log_warning "Skipping invalid function name: $func"
            continue
        fi
        
        # Check for duplicates
        if [[ " ${seen_functions[*]} " =~ " ${func} " ]]; then
            log_verbose "Skipping duplicate function: $func"
            continue
        fi
        
        validated_functions+=("$func")
        seen_functions+=("$func")
        log_verbose "Found function: $func"
    done <<< "$functions"
    
    if [[ ${#validated_functions[@]} -eq 0 ]]; then
        handle_error "no_functions_found" "$tools_txt"
        return 1
    fi
    
    # Output validated functions
    printf '%s\n' "${validated_functions[@]}"
    return 0
}

# ============================================================================
# Function Filtering and Sorting
# ============================================================================

# Sort function names alphabetically
sort_functions() {
    local functions=("$@")
    
    if [[ ${#functions[@]} -eq 0 ]]; then
        return 0
    fi
    
    printf '%s\n' "${functions[@]}" | sort -u
}

# Filter functions by pattern
filter_functions() {
    local pattern="$1"
    shift
    local functions=("$@")
    
    if [[ -z "$pattern" ]]; then
        printf '%s\n' "${functions[@]}"
        return 0
    fi
    
    log_verbose "Filtering functions with pattern: $pattern"
    
    local filtered=()
    for func in "${functions[@]}"; do
        if [[ "$func" =~ $pattern ]]; then
            filtered+=("$func")
            log_verbose "Matched: $func"
        fi
    done
    
    if [[ ${#filtered[@]} -eq 0 ]]; then
        log_warning "No functions matched pattern: $pattern"
        return 1
    fi
    
    printf '%s\n' "${filtered[@]}"
    return 0
}

# Process function list: extract, validate, filter, sort
process_function_list() {
    local tools_txt="$1"
    local filter_pattern="${2:-}"
    
    log_verbose "Processing function list..."
    
    # Extract functions
    local functions
    if ! functions=$(extract_function_list "$tools_txt"); then
        return 1
    fi
    
    # Convert to array
    local func_array=()
    while IFS= read -r func; do
        [[ -n "$func" ]] && func_array+=("$func")
    done <<< "$functions"
    
    log_verbose "Extracted ${#func_array[@]} functions"
    
    # Apply filter if provided
    if [[ -n "$filter_pattern" ]]; then
        local filtered
        if ! filtered=$(filter_functions "$filter_pattern" "${func_array[@]}"); then
            return 1
        fi
        
        func_array=()
        while IFS= read -r func; do
            [[ -n "$func" ]] && func_array+=("$func")
        done <<< "$filtered"
        
        log_verbose "Filtered to ${#func_array[@]} functions"
    fi
    
    # Sort
    local sorted
    sorted=$(sort_functions "${func_array[@]}")
    
    echo "$sorted"
    return 0
}

# ============================================================================
# Path Resolution Functions
# ============================================================================

# Resolve the relative path from bin/ directory to agent's tools.sh
resolve_tools_path() {
    local bin_dir="$1"
    local agent_name="$2"
    
    log_verbose "Resolving tools.sh path for agent: $agent_name"
    
    # Return relative path from bin/ to agents/<agent>/tools.sh
    local relative_path="../agents/${agent_name}/tools.sh"
    log_verbose "Resolved relative path: $relative_path"
    echo "$relative_path"
    
    return 0
}

# Validate that tools.sh exists and is accessible
validate_tools_path() {
    local tools_path="$1"
    
    log_verbose "Validating tools.sh path: $tools_path"
    
    # Check if file exists
    if [[ ! -f "$tools_path" ]]; then
        handle_error "missing_tools" "$tools_path"
        return 1
    fi
    
    log_verbose "âœ“ File exists"
    
    # Check if file is readable
    if [[ ! -r "$tools_path" ]]; then
        log_error "tools.sh is not readable: $tools_path"
        log_error "Please check file permissions"
        return 1
    fi
    
    log_verbose "âœ“ File is readable"
    
    # Check if file contains valid bash syntax
    if ! bash -n "$tools_path" 2>/dev/null; then
        log_error "tools.sh contains syntax errors: $tools_path"
        log_error "Please validate your bash syntax"
        return 1
    fi
    
    log_verbose "âœ“ Bash syntax is valid"
    log_verbose "âœ“ tools.sh validation passed"
    return 0
}

# ============================================================================
# Wrapper Template and Generation Functions
# ============================================================================

# Generate wrapper script template
generate_wrapper_template() {
    local function_name="$1"
    local agent_name="$2"
    local tools_relative_path="$3"
    local timestamp="$4"
    
    cat << EOF
#!/usr/bin/env bash
# Auto-generated wrapper for ${agent_name} agent function: ${function_name}
# Generated: ${timestamp}
# Generator version: ${SCRIPT_VERSION}
# DO NOT EDIT THIS FILE MANUALLY - Regenerate using generate_wrappers.sh

set -euo pipefail

# ============================================================================
# Wrapper Configuration
# ============================================================================

readonly WRAPPER_FUNCTION="${function_name}"
readonly WRAPPER_AGENT="${agent_name}"
readonly WRAPPER_VERSION="${SCRIPT_VERSION}"
readonly WRAPPER_GENERATED="${timestamp}"

# ============================================================================
# Path Resolution
# ============================================================================

# Locate the tools.sh script
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
TOOLS_SCRIPT="\${SCRIPT_DIR}/${tools_relative_path}"

# ============================================================================
# Error Handling
# ============================================================================

# Verify tools.sh exists
if [[ ! -f "\$TOOLS_SCRIPT" ]]; then
    echo "Error: tools.sh not found at \$TOOLS_SCRIPT" >&2
    echo "Expected path: \${SCRIPT_DIR}/${tools_relative_path}" >&2
    echo "Wrapper: \${WRAPPER_FUNCTION} (agent: \${WRAPPER_AGENT})" >&2
    exit 1
fi

# Verify tools.sh is readable
if [[ ! -r "\$TOOLS_SCRIPT" ]]; then
    echo "Error: tools.sh is not readable at \$TOOLS_SCRIPT" >&2
    echo "Please check file permissions" >&2
    exit 1
fi

# ============================================================================
# Debug Mode Support
# ============================================================================

# Enable debug mode if requested
if [[ "\${SH_AI_DEBUG:-false}" == "true" ]] || [[ "\${DEBUG:-false}" == "true" ]]; then
    echo "[DEBUG] Wrapper: \${WRAPPER_FUNCTION}" >&2
    echo "[DEBUG] Agent: \${WRAPPER_AGENT}" >&2
    echo "[DEBUG] Tools script: \$TOOLS_SCRIPT" >&2
    echo "[DEBUG] Arguments: \$*" >&2
    echo "[DEBUG] Argument count: \$#" >&2
fi

# ============================================================================
# Function Execution
# ============================================================================

# Source the tools.sh script
source "\$TOOLS_SCRIPT"

# Call the actual function with all arguments
${function_name} "\$@"
EOF
}

# Generate a single wrapper script
generate_wrapper() {
    local function_name="$1"
    local bin_dir="$2"
    local agent_name="$3"
    local tools_relative_path="$4"
    
    local wrapper_path="${bin_dir}/${function_name}"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    log_verbose "Generating wrapper: $function_name"
    
    # Check if wrapper already exists
    if [[ -f "$wrapper_path" ]] && [[ "$FORCE_OVERWRITE" != "true" ]]; then
        log_verbose "Wrapper already exists (use --force to overwrite): $function_name"
        return 0
    fi
    
    # Generate wrapper content
    local wrapper_content
    wrapper_content=$(generate_wrapper_template "$function_name" "$agent_name" "$tools_relative_path" "$timestamp")
    
    # Write wrapper to file
    if [[ "$DRY_RUN" == "true" ]]; then
        log_dry_run "Would create wrapper: $wrapper_path"
        return 0
    fi
    
    if echo "$wrapper_content" > "$wrapper_path"; then
        # Set executable permission
        if chmod +x "$wrapper_path"; then
            log_verbose "Wrapper created successfully: $function_name"
            return 0
        else
            log_error "Failed to set executable permission: $wrapper_path"
            return 1
        fi
    else
        log_error "Failed to write wrapper: $wrapper_path"
        return 1
    fi
}

# Generate all wrappers for a list of functions
generate_all_wrappers() {
    local bin_dir="$1"
    local agent_name="$2"
    local tools_relative_path="$3"
    shift 3
    local functions=("$@")
    
    local total=${#functions[@]}
    local generated=0
    local skipped=0
    local failed=0
    
    log_info "Generating wrappers for $total functions..."
    
    for func in "${functions[@]}"; do
        if generate_wrapper "$func" "$bin_dir" "$agent_name" "$tools_relative_path"; then
            if [[ "$DRY_RUN" != "true" ]]; then
                if [[ -f "${bin_dir}/${func}" ]]; then
                    ((generated++))
                else
                    ((skipped++))
                fi
            else
                ((generated++))
            fi
        else
            ((failed++))
            log_warning "Failed to generate wrapper: $func"
        fi
    done
    
    # Summary
    echo ""
    log_success "Wrapper generation completed"
    log_info "Generated: $generated"
    
    if [[ $skipped -gt 0 ]]; then
        log_info "Skipped: $skipped (already exist, use --force to overwrite)"
    fi
    
    if [[ $failed -gt 0 ]]; then
        log_warning "Failed: $failed"
        return 1
    fi
    
    return 0
}

# ============================================================================
# Cleanup Functions
# ============================================================================

# Clean obsolete wrappers that no longer exist in tools.txt
clean_obsolete_wrappers() {
    local bin_dir="$1"
    shift
    local valid_functions=("$@")
    
    log_info "Cleaning obsolete wrappers..."
    
    if [[ ! -d "$bin_dir" ]]; then
        log_warning "Bin directory does not exist: $bin_dir"
        return 0
    fi
    
    local cleaned=0
    local kept=0
    
    # Iterate through all files in bin directory
    for wrapper in "$bin_dir"/*; do
        [[ ! -f "$wrapper" ]] && continue
        
        local wrapper_name
        wrapper_name=$(basename "$wrapper")
        
        # Check if this wrapper corresponds to a valid function
        local is_valid=false
        for func in "${valid_functions[@]}"; do
            if [[ "$wrapper_name" == "$func" ]]; then
                is_valid=true
                break
            fi
        done
        
        if [[ "$is_valid" == "false" ]]; then
            # This wrapper is obsolete
            if [[ "$DRY_RUN" == "true" ]]; then
                log_dry_run "Would remove obsolete wrapper: $wrapper_name"
                ((cleaned++))
            else
                log_verbose "Removing obsolete wrapper: $wrapper_name"
                if rm "$wrapper"; then
                    ((cleaned++))
                else
                    log_warning "Failed to remove: $wrapper"
                fi
            fi
        else
            ((kept++))
        fi
    done
    
    echo ""
    log_success "Cleanup completed"
    log_info "Removed: $cleaned obsolete wrappers"
    log_info "Kept: $kept valid wrappers"
    
    return 0
}

# ============================================================================
# Main Function
# ============================================================================

main() {
    # Parse command line arguments
    parse_arguments "$@"
    
    # Display header
    if [[ "$VERBOSE" == "true" ]]; then
        echo "========================================"
        echo "AIChat Function Wrapper Generator"
        echo "Version: ${SCRIPT_VERSION}"
        echo "========================================"
        echo ""
        log_verbose "Agent: ${AGENT_NAME}"
        log_verbose "Functions root: ${FUNCTIONS_ROOT}"
        log_verbose "Bin directory: ${BIN_DIR}"
        echo ""
    fi
    
    # Validate configuration
    log_info "Validating configuration..."
    
    # Check agent directory exists
    local agent_dir="${FUNCTIONS_ROOT}/agents/${AGENT_NAME}"
    if [[ ! -d "$agent_dir" ]]; then
        log_error "Agent directory not found: $agent_dir"
        exit 3
    fi
    log_verbose "Agent directory found: $agent_dir"
    
    # Check tools.txt exists
    local tools_txt="${agent_dir}/tools.txt"
    if [[ ! -f "$tools_txt" ]]; then
        handle_error "missing_tools_txt" "$tools_txt"
        exit 3
    fi
    log_verbose "tools.txt found: $tools_txt"
    
    # Check and validate tools.sh
    log_info "Validating tools.sh..."
    local agent_tools="${agent_dir}/tools.sh"
    if ! validate_tools_path "$agent_tools"; then
        log_error "tools.sh validation failed"
        exit 3
    fi
    
    log_success "Configuration validated"
    echo ""
    
    # Ensure bin directory exists
    if [[ ! -d "$BIN_DIR" ]]; then
        log_info "Creating bin directory: $BIN_DIR"
        if [[ "$DRY_RUN" == "false" ]]; then
            if ! mkdir -p "$BIN_DIR"; then
                handle_error "bin_dir_creation_failed" "$BIN_DIR"
                exit 3
            fi
        else
            log_dry_run "Would create directory: $BIN_DIR"
        fi
    fi
    
    # Extract and process function list from tools.txt
    log_info "Extracting function list from tools.txt..."
    
    if [[ -n "$FILTER_PATTERN" ]]; then
        log_verbose "Applying filter pattern: $FILTER_PATTERN"
    fi
    
    local function_list
    if ! function_list=$(process_function_list "$tools_txt" "$FILTER_PATTERN"); then
        log_error "Failed to extract function list"
        exit 4
    fi
    
    # Convert to array for processing
    local functions=()
    while IFS= read -r func; do
        [[ -n "$func" ]] && functions+=("$func")
    done <<< "$function_list"
    
    if [[ ${#functions[@]} -eq 0 ]]; then
        log_error "No valid functions found in tools.txt"
        exit 4
    fi
    
    log_success "Found ${#functions[@]} functions"
    
    if [[ "$VERBOSE" == "true" ]]; then
        echo ""
        log_info "Function list:"
        for func in "${functions[@]}"; do
            echo "  - $func" >&2
        done
    fi
    
    echo ""
    
    # Clean mode - remove obsolete wrappers
    if [[ "$CLEAN_MODE" == "true" ]]; then
        clean_obsolete_wrappers "$BIN_DIR" "${functions[@]}"
        echo ""
    fi
    
    # Dry run mode
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Dry run mode - no changes will be made"
        echo ""
        log_info "Would generate wrappers for ${#functions[@]} functions:"
        for func in "${functions[@]}"; do
            echo "  ${ICON_GENERATE} $func -> ${BIN_DIR}/$func"
        done
        echo ""
        log_success "Dry run completed"
        exit 0
    fi
    
    # Calculate relative path from bin/ to agent tools.sh
    log_verbose "Calculating tools.sh relative path..."
    local tools_relative_path
    tools_relative_path=$(resolve_tools_path "$BIN_DIR" "$AGENT_NAME")
    log_verbose "Using relative path: $tools_relative_path"
    
    # Generate all wrappers
    echo ""
    if generate_all_wrappers "$BIN_DIR" "$AGENT_NAME" "$tools_relative_path" "${functions[@]}"; then
        echo ""
        log_success "All wrappers generated successfully"
        log_info "Wrappers location: $BIN_DIR"
        
        if [[ "$VERBOSE" == "true" ]]; then
            echo ""
            log_info "Generated wrappers:"
            for func in "${functions[@]}"; do
                if [[ -f "${BIN_DIR}/${func}" ]]; then
                    echo "  ${ICON_SUCCESS} $func"
                fi
            done
        fi
        
        echo ""
        log_info "Next steps:"
        echo "  1. Add $BIN_DIR to your PATH"
        echo "  2. Test a wrapper: ${BIN_DIR}/ssh_status"
        echo "  3. Use functions in AIChat agent"
        
        exit 0
    else
        echo ""
        log_error "Some wrappers failed to generate"
        exit 4
    fi
}

# ============================================================================
# Script Entry Point
# ============================================================================

main "$@"